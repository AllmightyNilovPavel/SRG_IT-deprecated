# End to end тестирование

[TOC]

## Запуск локально на UNIX

**Для этого требуется чтобы в системе было установлено:**
- git для работы пакетного менеджера npm [git-scm.com](https://git-scm.com/)
- node.js для запуска самих тестов [nodejs.org](https://nodejs.org/en/)
- nvm - менеджер версий `node.js`

**Запуск:**

- Из репозитория `/tests/` перейти в папку `/end2end/` в корне проекта
- Запустить команды:

```bash
yarn install		# Поставит все нужные пакеты
			#(можно выполнять только в первый раз)
yarn test 		# Запустит все тесты в хроме
yarn test ba # запустит все тесты, которые содержат в названии файла ba
yarn suite krona_smoke # запустит группу тестов относящихся к тестам типа SMOKE по Кроне
yarn show 	# откроет отчет в браузере (по желанию)
```

- Если надо изменить дефолтные параметры (описаны в **src/options/**):

```bash
# Описать переменные окружения которые переписывают настройки
# (_ вместо точки)
export option_ba_host="https://ba.srg-it.ru"
export option_ba_login="test-login@srg-it.ru"
export option_ba_password="testpass"

yarn test

```

## Запуск на windows

- установить git [git-scm](https://git-scm.com/download/win)
- Установить NVM [github/nvm-windows](https://github.com/coreybutler/nvm-windows/releases/tag/1.1.8)
- Установить менеджер пакетов YARN [yarnpkg.com](https://classic.yarnpkg.com/en/docs/install/#windows-stable)
- Перезагрузить ПК

**Скачать репозиторий:**

- git clone git@bitbucket.org:srg-dev/tests.git

**Перейти в папку с тестами и установить зависимости:**

- `cd tests/end2end`
- `nvm install 14.16.1`
- `nvm use 14.16.1`
    - после этой команды желательно перезагрузить ПК
- `yarn install`


**Установить редактор**

VScode [MicrosoftVsCode](https://code.visualstudio.com/)
или `intelliJ-idea`

**Редактор**

- По желанию можно поставить нужные плагины для поддержки того, что используется в тестах:
    - typescript + tslint - типизированный js и линтер [typescriptlang.org](www.typescriptlang.org)
    - mocha - для запуска тестов [mochajs.org](https://mochajs.org/)
    - chai - библиотека ассертов [chaijs.com](http://chaijs.com/)
    - webdriverio - для работы с api браузера [webdriver.io](http://webdriver.io/)
- Быстрее всего, если нет готового редактора поставить [vscode](https://code.visualstudio.com/), и плагины на него:
    - tslint
    - Chai snippets
    - es6 mocha snippets

## Написание тестов

**src/options**  
- Тут будут описаны все дефолтные опции для тестирования. 
    - В файле `index.ts` будут содержаться основные данные для запуска тестов, такие как:
        * Параметр параллельного запуска тестов
        * Параметры основных `URL` для запуска тестов по проектам
    - В папке `TestData` должны быть описаны тестовые данные для разных проектов, например:
        * Тестовые пользователи
        * Наборы данных для создания запросов\заказов (например для Кроны)
- Дефолтные опции формируются следующим образом:
    - Перед началом выполнения тестов выполняется процедура компиляции (сборки) файла `index.ts` с основными опциями.
      В зависимости от окружения (тест или прод) берётся файл с параметрами `URL` (которые описаны в файлах `hosts.test|prod.ts`) и все данные из него 
      "склеиваются" с данными в файле `index.ts`. После этого сканируются переменные окружения исполняемой среды (компьютера\\контейнера)
      в которой запускаются тесты и если среди переменных окружения присутствуют такие которые начинаются на `OPTION_` то они заменяют собой
      соответствующие переменные в этом файле (`index.ts`) и только после этого запускается процедура выполнения теста.

**src/pages**
Этот раздел предназначен для хранения *PageObjects* и *PageFactories* с которыми потом будем работать в тестах.

- В PageObject'ах мы описываем _базовые селекторы_ с которыми мы будем работать
    - В приоритете `xPath`, если нет возможности написать на нём тогда `CSS` 
- На страницах PageFactory мы описываем _методы_, которые взаимодействуют с селекторами из *PageObjects*.

Уровни вложенности папок содержащих в себе PageObjects и PageFactories регулируются проектами.

**src/spec**  
В этой папке хранятся все файлы самих тестов.

- Типичный сценарий:
    - Импорт нужных страниц, с которыми будет работа из папки src/pages
    - Выполнение нужных действий над одними элементами, проверка других
    - При действиях, которые занимают какое-то время, необходимо дожидаться сигнала, что действие закончено 
      например при логине, дожидаться пока форма логина исчезнет и на странице появится кнопка выхода.

```typescript
loginPage.$login_form.waitForExist({timeout: 10000, reverse:true}); // true значит пока исчезнет
this.$button_logout.waitForExist();
this.$loading_overlay.waitForExist({timeout: 20000, reverse:true}); // лоадер исчез
```

## Где искать документацию

- webdriverio для работы с элементами на странице
    - есть отличный сайт [webdriver.io](http://webdriver.io/)
    - описание api [webdriver.io/api.html](http://webdriver.io/api.html)
    - краткий гайд [webdriver.io/guide/usage/selectors.html](http://webdriver.io/guide/usage/selectors.html)
    - примеры, как писать тесты [github.com](https://github.com/webdriverio/webdriverio/tree/master/examples)
    - issue трекер, где уже есть ответы на кучу вопросов https://github.com/webdriverio/webdriverio/issues
    - gitter чат, где постоянно сидят кто-то из разработчиков или опытных в этом деле людей, всегда можно что-то спросить [gitter.im](https://gitter.im/webdriverio/webdriverio)
- mocha для запуска тестов [mochajs.org](https://mochajs.org/)
- chai
    - гайд [chaijs.com/guide](http://chaijs.com/guide/styles/)
    - api [chaijs.com/api](http://chaijs.com/api/)
- typescript
    - краткий обзор [typescriptlang.org/docs/handbook](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
    - подробная документация [typescriptlang.org/docs/handbook/basic-types](https://www.typescriptlang.org/docs/handbook/basic-types.html)
    - полезно посмотреть как работать с import/export [typescriptlang.org/docs/handbook/modules](https://www.typescriptlang.org/docs/handbook/modules.html)
    - Если нормально настроить редактор, подсказывает где-какие методы есть, документацию, переходы по ctrl и т.д., очень удобно. Так же будет ругаться при компиляции если где-то косяк с типами, синтаксисом или неопределенными переменными

## XPath

Можно селектить элементы на странице как через css селекторы,
например `\$(".someclass sometag#someid")`, но часто бывает такого синтаксиса не достаточно,
тогда есть более мощный синтаксис xpath который позволяет брать родителей, соседей и селектить например по тексту внутри аттрибута

https://ru.wikipedia.org/wiki/XPath

пример xpath

```typescript
$(`//table//*[@id="year"]/../select[1]`)
```

найдет эелемент с id=year внутри таблицы, и возьмет первый select внутри его родителя.
такое бывает полезно когда есть хороший id у какого-то соседнего элемента,
и можно найти нужный элемент по относительному пути

### Быстрые подсказки
- `//` - элемент внутри текущего контекста на любом уровне вложенности
- `/tag` - элемент с названием тега "tag" на первом уровне вложенности
- `/\*[@id="year"]` - любой элемент на первом уровне вложенности с id=year
- `/../` - родительский элемент
- `/select[1]` - первый select на первом уровне вложенности
- `//div[@class='1' or @class='2']` - любой элемент типа *div* у которого имеется класс *1* или *2*
- если нужно найти какой-то элемент на странице но имя атрибута динамическое - можно использовать поиск по совпадению
    - пример №1: `$('//div[contains(@class,"classNamePart")]')`
    - пример №2: `$(//*[contains(text(),'test')])`
- Стоит избегать селекторов которые легко сломать при изменении кода
  так как структура страницы меняется часто, и почти любая правка сломает код.
  Надо находить рядом хорошие (стабильные \ хорошо описанные \ не динамические) _id элементов или классы_, или же добавлять их вручную в код специально ради тестов.
    - Пример нестабильного селектора: `/div/div/table/div[6]/div[2]/select`
### Таймеры и ожидание подгрузки элементов и каких-то событий

#### Общая информация
есть разные методы завязанные на время, например
`browser.pause(ms)`
`element.waitForDisplayed({timeout: ms, reverse: boolean, timeoutMsg:string})`

они нужны чтобы дождаться появления какого-то элемента на страницы во время подгрузки.
Возникает соблазн ставить таймеры в виде `browser.pause(1000)`, но это крайне не желательно делать
так как тогда время тестирования гарантированно увеличивается на одну секунду независимо от времени загрузки элемента,
во вторых элемент может не прогрузиться за это время, из-за какого-то случайного локального тормоза одной из систем.
Тогда тесты будут крайне не стабильные и медленные.

Всегда надо стараться дожидаться появления ключевых элементов с помощью `waitForDisplayed`,
появление которых или исчезание сигнализирует о завершении загрузки чего либо.
При чем не стоит делать очень маленький `timeout` на ожидание этого элемента,
например если обычно элемент грузится за `200мс`, можно поставить таймаут 2-3 секунды,
так как при обычном режиме он будет быстро отрабатывать за минимальное время загрузки,
а при небольшом временном тормозе, тесты не будут разваливаться, иначе тесты будут не стабильными.

### Организация тестов

Обычно при написании тестов, сначала пишут селекторы к необходимым элементам на странице, в файле относящемся к этой страницы.
Это позволяет потом переиспользовать код селекторов для других тестов.

Затем можно вынести в отдельные процедуры код, который переводит страницу из одного состояния в другое.
Например процедура которая закрывает все попапы, или процедура которая заполняет ключевые поля одной из форм.
Тогда можно будет переиспользовать минимальные необходимые шаги для более сложных цепочек более крупных тестов.

Сами спеки тестирования надо стараться делать максимально короткими.
Обычно каждая спека включает логин, переход на нужную страницу и само тестирование какого-то функционала.

Не стоит делать очень длинные цепочки в одном тесте, так как это усложняет отладку и тесты становятся менее гранулярными.
Но это довольно сложно соблюдать когда нужно предварительно подготовить сложную форму, создать отчет и только потом тестировать.
Тогда наверно логичнее в одном же тесте создать его и в нем же прогнать кучу разных проверок, чтобы не пересоздавать его на каждую проверку.
Иначе будет очень долго отрабатывать.

## Соглашения
### Именование файлов
Имена всех файлов должны придерживаться одной общей концепции нейминга чтобы не было путаницы и было удобно их искать по всему проекту.

- Имя файла всегда начинается со слова определяющего его принадлженость к определённому проекту 
    - *krona* \\ *ba* \\ *baikal* \\ *fa*
- Имя файла должно содержать краткое описание того что оно в себе содержит:
    - *krona.enum* \\ *ba.pageObject* \\ *fa.pageFactory*
- Если содержимое файла имеет прямое отношение к какому-то банку оно должно содержать в себе краткую информацию о принадлежности этому банку.
  Такая запись убдет означать что всё содержимое файла стоит использовать только в тестах имеющих отнощение к этому банку.
    - *krona.enum.selhoz* \\ *ba.pageObject.vehicle.vtb*

### Именование классов
- Имя класса должно быть написано в [CamelCase](https://dic.academic.ru/dic.nsf/ruwiki/328657)
- Имя класса должно начинаться с проекта к которому он относится
    - *KronaBlaBlaBla* \\ *BaikalBlaBlaBla* \\ *FaBlaBlaBla*
- Имя класса должно содержать в себе краткое описание к какому разделу проекта относится класс
    - Например: *KronaResidentialRegistry* \\ *KronaCommercialRegistry* - сразу понятно что эти два класса относятся к жилой и коммерческой недвижимости соответственно.

### Именование тестов
При написании имени теста в блоке `describe('TestName', function(){})` следует придерживаться одной общей концепции нейминга для того чтобы поддерживать общий вид.

- Имена тестов должны начинаться с проекта к которому они относятся.
  Имя проекта должно быть написано в верхнем регистре.
    - Например: `describe('КРОНА. Тест №1', func() {})` \\ `describe('БО. Тест №2', func() {})` \\ `describe('БАЙКАЛ. Тест №3', func() {})`
- В имени теста, после принадлежности к проект, должно следовать имя банка (если тестируется функционал относящийся только к этому банку)
    - Например: `describe('КРОНА. ВТБ. Тест №1', func() {})` \\ `describe('БО. РОСБАНК. Тест №2', func() {})` \\ `describe('БАЙКАЛ. РСХБ. Тест №3', func() {})`
- В имени теста не должно быть знаков `\` или `|` или `/`, так как могут возникнуть проблемы при формировании скриншота для этого теста.
  Допускается использование символа `.`, `_` или `-`.
- Если имя теста очень большое, то его лучше вынести в переменную и передавать в метод уже её.
    - Например: `const testName = 'test'` \\ `describe(testName, func(){})`

### Тестовые пользователи
- Для каждого отдельного теста или группы тестов нужно создавать отдельного пользователя
    - С уникальным набором прав
- Имена пользователей нужно записывать в стиле [snake_case](https://ru.wikipedia.org/wiki/Snake_case)
- Имя пользователя должно начинаться с ключевого слова *autotest*
- Имя пользователя должно содержать наименование банка к которому он относится
    - *autotest_vtb_test* \\ *autotest_rshb_test*
- Имя пользователя должно содержать в себе краткое описание принадлежности к отдельному тесту или группе тестов
    - Описание принадлежности может быть записано в `CamelCase`
    - *autotest_vtb_vehicle* \\ *autotest_vtb_commercial* \\ *autotest_openbank_checklistUrz*

### Организация расположения файлов с тестами
- Все файлы тестов должны хратиться в соответствующих папках относящихся к проекту.
    - `./src/krona/*` \\ `./src/ba/*` \\ `./src/baikal/*`
- Файлы с тестами должны разделяться по видам тестирования.
    - Если имеется группа тестов которая тестирует фкнционал на уровне `SMOKE` то они все должны лежать в соответствующей папке внутри проекта.
      Например: `./src/Krona/smoke/*`
        - Это позволит более удобно вызывать группы тестов для тестирования. Организовывать их в `suite` или вызывать одной командой по совпадению имён.
- `Здесь могла бы быть ваша реклама`


### Базовые методы для PageObject
Этот раздел посвящён базовым методам описывающим объект типа "страница" с которой мы потому будем взаимодействовать через тесты.

- У каждой страницы должен путь до неё в константе `path` 

Пример PageObject
```typescript
    export class TestPage{
      path = 'https://test.srg-it.ru/9r'
      private get $root(){
        return $(`//div[@id='root']`)
      }

      get $testSelector(){
        return this.$root.$(`.//*[@class='elementSelect']`)
      }

      get $testInput(){
        return this.$root.$(`.//div[@class='elementInput' or @class='textarea']`)
      }
    }
```

### Базовые методы для PageFactory
Этот раздел будет посвящён базовым методам которые должны быть у каждого класса описывающего методы работы с той или иной страницей.

- Ожидание загрузки.
  Нам всегда приходится ждать что та или иная страница загрузится. Для этого мы, обычно, пишем один и тот же набор методов которые позволяют определить что нужная нам страница загружена. Для того чтобы универсализировать подход мы будем для каждой такой страницы описывать базовый метод с именем `waitForLoad()` который нужен для ожидания прогрузки ключевых элементов страницы, которых достаточно для работы с ней.

Пример PageFactory
  ```typescript
  export class TestFactory extends TestPage {
    waitForLoad(){
      browser.waitUntil(() => browser.getUrl().match(this.path) !== null)
      this.$root.waitForExist()
    }
  }
  ```
### Вспомогательные методы
Прежде чем добавлять какой-то новый метод\функцию или извлекать руками какое-то значение откуда-либо - посмотри в папку `/src/modules`
Там описаны все вспомогательные методы которые используется по всему проекту и часто.

## Известные проблемы:
### Проблемы с вызовом селекторов по цепочке
- Длинные `chain-селекторы` могут приводить к ошибкам в коде. Длинные значит больше 4-х.
  Фреймворк может просто не найти элемент потому что в какой-то момент цепочка поломалась и мы не поймём в какой.
- Когда мы формируем селектор внутри какой-то функции сразу на момент его определения а потом вызываем эту функцию много раз - то все `chain-селекторы`
  которые зависят от этого первого - будут всегда ссылаться на его первую версию.
    - Пример: 
      ```typescript
      export func(number){
        let selector = $(`//div[@class="${1 + 2 * number }"]`)
        let chainSelector = selector.$(`.//div[@id="test"]`)
        console.log(`${chainSelector.id}`) // Будет выводить в консоль всегда один и тот же айди
      }
      ```
      Решить это довольно легко. Нужно разделить определение переменной `selector` от присваивания ей значения.
      ```typescript
      let selector: WebdriverIo.Element
      selector = $(`//div`)
      ```
### Нюансы проверки доступности элементов на странице
- Не стоит использовать метод `element.waitForExist()` отдельно от других по типу `element.waitForDisplayed()`
  потому что `exist` это просто проверка на существование элемента на странице и он может существовать сам по себе даже если его не видно.

### Нюансы ожидания прихода сущностей из одной системы в другую
- Когда мы формируем любого рода отчёт в Банк-Оценщике и хотим проверить что он пришёл в другую систему `Крону \ ЗЗО` то это может занять много времени.
  Лучше всего в таких (✨ и только в таких случаях ✨) использовать неявное (`browser.pause()`) ожидание.

## \_\_\_

Job в дженкинсе [https://jenkins.srg-it.ru/view/All/job/end_to_end_test/](https://jenkins.srg-it.ru/view/All/job/end_to_end_test/)

Отчет в дженкинсе [https://jenkins.srg-it.ru/view/All/job/end_to_end_test/allure/](https://jenkins.srg-it.ru/view/All/job/end_to_end_test/allure/)
